import pylab
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy
import pickle
import pdb
import csv
import pandas as pd
import timeit
import sys

class Maximum_of_Gaussian():

    def __init__(self):
       self.dimensions= 2
       
     
    def guassian_approx(self):
       X=numpy.sort(self) #sort RVs by their mean
       idx  = X.shape[0]
       Q = -1*numpy.ones((2*idx, 2))
       Q [0:idx,:] = X


       X_g = Q[0,:]
       Q[0,:] = []
       idx = idx - 1

       while(numpy.sum ( numpy.where (Q[:,1] == -1)[0] ) ~= Q.shape[0]):
    
           idx = idx + 1
           Q[idx,:] = X_g
           X = numpy.r_[ Q[0,:],  Q[1,:] ]
           Q[0:2,:] = []
           idx = idx - 2
           if(X[0,1] == X[1,1] and X[1,1] == 0  and X[0,0] == X[1,0] ):
             	X_g = [X(0,0), X(0,1)]
           else:
		corr = 0
		a = numpy.sqrt(X[0,1]**2 + X[1,1]**2 - 2*corr*X[0,1]*X[1,1])
		alpha = (X[0,0] - X[1,0])/a

		X_g[0] = X[0,0]*(0.5*erfc(-alpha/sqrt(2))) + X[1,0]*(0.5*erfc(alpha/sqrt(2))) +a*(exp(-0.5 * (alpha)^2)/(sqrt(2*pi)));

		var_g = numpy.max((X[0,1]**2 + X[0,0]**2)*(0.5*erfc(-alpha/sqrt(2))) + (X[1,1]**2 + X[1,0]**2)*(0.5*erfc(alpha/sqrt(2))) + (X[1,1]+X[2,1])*a*(exp(-0.5 * (alpha)^2)/(sqrt(2*pi))) - X_g[0]**2, 0);
		X_g[2] = sqrt(var_g);
  
    
    return X_g


